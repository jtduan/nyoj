# 知识点
## 树状数组 bitree
    - 实现方式:主要包含`init`,`update`和`query`方法
## 大根堆和小根堆 heap
    - 实现方式:主要包含`HeapUp`和`HeapDown`方法
    - java中可以使用现成的实现：优先队列(PriorityQueue）
## 红黑树 rbtree(待研究）
    - java中红黑树现成的实现：TreeMap
## 博弈论
    - 巴什博弈(1堆,取1-n个)
        + `num % (limit + 1)` 结果大于0时，先出手的胜利，等于0时，后出手胜利
    - 威佐夫博弈(2堆,从一堆取任意多或两对取一样多）
        + (n2-n1)*(sqrt(5)+1)/2 == n1 时（黄金分割点），后出手胜利
    - 尼姆博弈(n堆,从一堆取任意多)
        + ans ^= pernum 结果大于0时，先出手的胜利，等于0时，后出手胜利
    - 斐波那契博弈（1堆，每次不能超过对手取得个数的2倍，第一次不能取完）
        + n为斐波那契数 后出手胜利

## 凸包问题
    - Graham Scan算法
    - GiftWrapping算法

## 网络流问题
    - Edmonds - Karp 算法
    - SFPA算法求最短增广路

## 置换群(待研究)
    - 求出每个循环节的个数,再求所有循环节的个数的最小公倍数

## 二分图
    - 匈牙利算法

## other
    - 使用队列进行BFS搜索时，入队时标记 效果好于 出队时标记（`nyoj92`）
    - 乘除2时可以使用移位代替
    - 可以使用静态数组模拟循环较少的情况（比如矩阵的BFS`nyoj92`,`nyoj52`）
    - 一般适用范围值时，都是含左不含右，可以避免边界条件判断
    - 可以考虑扩大数组的范围以减少边界条件判断


## 解题步骤
    - 考虑使用动态规划 找到递推关系（最长公共子序列）
        - 考虑使用数组存储结果的中间值（最长递增子序列，数组下标为长度）
        - 使用数组存储个数的中间值（nyoj16,最长递增子序列，数组下标为以该数字结尾的最大长度）
    - 考虑合适的数据结构，堆（大根堆和小根堆）栈（递增栈）和队列（优先队列），
    - 考虑集合类型 和排序的集合类型SortedSet和SortedHashMap(key为数组下标的数组）
    - 考虑贪心算法
    - 使用双链表遍历
    - 树
    - 图
        - 欧拉回路（包含混合图的欧拉回路）
        - 哈密顿回路（DFS,类似八皇后问题）
        - 最小生成树
            - 次小生成树:生成最小生成树时额外记录节点中的点到该点的最大的一跳之间长度,最小生成树构造完成后,将不在最小生成树的边(i,j)
            加入树,在将,i到j的原先最大边删除,依次测试每条不在最小生成树的边,最终结果最小的就是次小生成树
        - BFS/DFS
    - other
        - huffman
        - 数学算法
        - 排序算法
        - 二分查找
        - 并查集